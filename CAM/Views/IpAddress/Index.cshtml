@using CAM.Core.Domain
@model IpAddressViewModel
@{
    ViewBag.Title = "Index";
}
@section AdditionalScripts
{
    <script type="text/javascript">
        (function () {

            var securityToken = $('input[name="__RequestVerificationToken"]').val();

            function renderButton($textElement, id) {

                // My old way:
                //var button = document.createElement("input");
                //button.type = 'button';
                //button.className = 'findHostName btn btn-mini';
                //button.value = 'Reverse DNS';
                //button.id = 'btnFindHost';
                //$(button).attr('data-id', id);

                // Another way:
                //var button = "<input type='button' id='btnFindHost' class='findHostName btn btn-mini' value='Reverse DNS' data-id='" + id + "' />";

                // jQuery way using a data map.  Note that I could have also chained attr together, but I think this is more readable.
                var button = $("<input />").attr({
                    'type': 'button',
                    'id': 'btnFindHost',
                    'class': 'findHostName btn btn-mini',
                    'value': 'Reverse DNS',
                    'data-id': id
                });

                $textElement.siblings("img.waiting").before(button);
            }

            // This can be changed to a delagate using a context of "ipAddressTable", then the event would only have to bubble up the least number of levels for new items
            // added to the DOM.
            //$('.editHostName').live('change', function () {
            // and revised to use the delegated version of the on function:
            $('.tab-content').on('change', '.editHostName', function () {
                var $textBox = $(this);
                var $button = $textBox.siblings(":button");
                var $imgWaiting = $textBox.siblings("img.waiting");

                $imgWaiting.attr("style", "display:inline;");

                var txtHostName = escape($textBox.val());
                var id = $.trim($textBox.data('id'));

                var IpAddressViewModel = {
                    Id: $.trim($textBox.data('id')),
                    Host: $.trim($textBox.val()),
                    __RequestVerificationToken: securityToken
                }

                // Old ajax call using WebAPI that correctly returns HttpResponseMessage and has direct access to StatusCode.
                //
                /*                $.ajax({
                                    url: '@Url.Action(null,"api/ipaddressapi")',
                                    data: JSON.stringify(IpAddressViewModel) ,  // Note that the model must be stringifed if using the WebAPI approach.
                                    type: "Post",
                                    contentType: "application/json;charset=utf-8",
                                    statusCode: {
                                        //Web API Post method returns status code as 201
                                        201: function () {
                                            alert("New record added successfully");
                                        },
                                        //Web API Put method returns status code as 200
                                        200: function () {
                                            $imgWaiting.attr("style", "display:none;");
                                            if (txtHostName != null && txtHostName != "") {
                                                $button.remove();
                                            }
                                        },
                                        204: function () {
                                            // record has been cleared and set to null.
                                            renderButton($textBox, id);
                                            $imgWaiting.attr("style", "display:none;");
                                        }
                                    }
                                });
                                */

                // Note that WebAPI correctly returns HttpResponseMessage with the desired StatusCode, where as ApplicationController wraps the return value in something else
                // that makes it extreemly difficult to actually get at the responseText object; therefore, I need to change the return type to JsonNetResult and parse the
                // jqHXR.responseText back into an object to regain access to it.
                // Also the content type must be changed to $.post's default as opposed to 'json' in order to correctly handle the anti-forgery token; otherwise, it there is
                // no easy way to get around the anti-forgery token not provided issue.  Much easier and straight forward to use WebAPI in my opinion for situations when you actually
                // desire an http response object back.
                $.post('@Url.Action("Post","IpAddress")', IpAddressViewModel, function (data, statusText, jqHXR) {
                    var jsonResponse = JSON.parse(jqHXR.responseText);
                    var statusCode = jsonResponse.StatusCode;
                    if (statusCode == 200) {
                        $imgWaiting.attr("style", "display:none;");
                        if (txtHostName != null && txtHostName != "") {
                            $button.remove();
                        }
                    }
                    else if (statusCode == 204) {
                            // record has been cleared and set to null.
                        renderButton($textBox, id);
                        $imgWaiting.attr("style", "display:none;");
                    }
                    else {
                        alert('Something unexpected happened: ' + statusCode);
                    }
                }, 'json');
            });

            //$('.findHostName').live('click', function () {
            $('.tab-content').on('click', '.findHostName', function () {
                var $button = $(this);
                var $textBox = $button.siblings(":text");
                var $imgWaiting = $button.siblings("img.waiting");

                $imgWaiting.attr("style", "display:inline;");

                var txtHostName = escape($textBox.val());
                var id = $.trim($button.data('id'));

                // When not using WebAPI it is not necessary to pass a data mapped object, but the parameter must be passed in the query string.
                //var IpAddressModel = {
                //    Id: id,
                //    Host: txtHostName
                //}

                if (txtHostName == "") {
                    // Old way using the lower-level $.ajax call
                    //$.ajax({
                    //    type: "GET",
                    //    url: "../api/ipaddressapi/" + id,
                    //    data: JSON.stringify(IpAddressModel),
                    //    contentType: "application/json;charset=utf-8",
                    //    dataType: "JSON",
                    //    success: function (data) {
                    //        var ip = data.Id;
                    //        var host = data.Host;
                    //        $textBox.val(host);
                    //        if (host != null && host != "") {
                    //            $button.remove();
                    //            $textBox.trigger('change');
                    //        }
                    //    },
                    //    complete: (function (data) {
                    //        var responseText = JSON.parse(data.responseText);
                    //        var message = responseText["ExceptionMessage"];
                    //        if (message != null && message != "") {
                    //            $button.val($button.val() + "*");
                    //        }

                    //        $imgWaiting.attr("style", "display:none;");
                    //    })
                    //});

                    // Sample of using $.getJSON instead of lower-level ajax call (see above):
                    //@*                    $.getJSON('@Url.Action(null, "api/ipaddressapi/")' + id, JSON.stringify(IpAddressModel), function (data) {
                    //                        var ip = data.Id;
                    //                        var host = data.Host;
                    //                        $textBox.val(host);
                    //                        if (host != null && host != "") {
                    //                            $button.remove();
                    //                            $textBox.trigger('change');
                    //                        }
                    //                        else {
                    //                            var message = data.ExceptionMessage;
                    //                            if (message != null && message != "") {
                    //                                $button.val($button.val() + "*");
                    //                            }

                    //                            $imgWaiting.attr("style", "display:none;");
                    //                        }
                    //                    });*@

                    // When not using WebAPI it is not necessary to pass a data mapped object, so it is set to null in the following method, and the
                    // id is passed in the query string.  Actually, I was not able to get the mapping from data object to MVC input parameter to work
                    // correctly once I revised it to use a standard MVC controller vs. a WebAPI controller, where as before, I only needed to pass the object,
                    // not append anything to the query string to get things to map properly.
                    $.getJSON('@Url.Action("Get","IpAddress")' + "/" + id, null, function (data) {
                        var ip = data.Id;
                        var host = data.Host;
                        $textBox.val(host);
                        if (host != null && host != "") {
                            $button.remove();
                            $textBox.trigger('change');
                        }
                        else {
                            var message = data.ExceptionMessage;
                            if (message != null && message != "") {
                                $button.val("Reverse DNS" + "*");
                            }

                            $imgWaiting.attr("style", "display:none;");
                        }
                    });
                }
                else {
                    // leave the host name as-is, and turn off the waiting image:
                    $imgWaiting.attr("style", "display:none;");
                }
            });

        })();
    </script>
}
@Html.AntiForgeryToken()
<h2>IP Addresses</h2>
<div class="tabbable">
    <!-- Only required for left/right tabs -->
    <ul class="nav nav-tabs">
        @{
            var i = 1;
            foreach (var r in Model.IpAddressRanges.OrderBy(r => r.TabOrder))
            {
                var tabString = "#tab" + i;
                var activeString = "active";
            <li @(r.TabOrder == 1 ? "class=" + @activeString : "") ><a href="@tabString" data-toggle="tab">@r.Id</a>
            </li>
                i++;
            }}
    </ul>
    <div class="tab-content">
        @{
            i = 1;

            foreach (var r in Model.IpAddressRanges.OrderBy(r => r.TabOrder))
            {
                var tabIdString = "tab" + i;
                var tabPaneClass = (r.TabOrder == 1 ? "tab-pane active" : "tab-pane");
            <div class="@tabPaneClass" id="@tabIdString">
                <table class="table table-striped table-condensed">
                    <tr>
                        <th>IP Address</th>
                        <th>Host Name</th>
                        <th>DNS Name(s)</th>
                    </tr>

                    @foreach (var ip in r.IpAddresses)
                    {

                        <tr>
                            <td>@ip.Id</td>
                            <td>
                                <input type="text" value="@ip.Host" id='@("hostName" + @ip.SortOrder)' name="hostName" class="editHostName input-medium" data-id="@ip.Id" />
                                @if (@ip.Host == null || @ip.Host == "")
                                {
                                    <input type="button" class="findHostName btn btn-mini" value="Reverse DNS" id="btnFindHost" data-id="@ip.Id" />
                                }
                                <img src='@Url.Image("wait30trans.gif")' style="display: none;" alt="processing" class="waiting"/>
                            </td>
                            <td>
                                <ul class="unstyled">
                                    @foreach (var dns in ip.DnsNames)
                                    {
                                        <li>
                                            @dns.Name
                                        </li>
                                    }
                                </ul>
                            </td>
                        </tr>
                    }
                </table>

            </div>
                    i++;
            }
        }
    </div>
</div>